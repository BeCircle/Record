## 1. 数据结构

### 1.1 数组&矩阵

+ [二维数组(从左到右递增，从上到下递增)中的查找](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
  + 从左下角开始，大于目标值往右，小于目标值往上
+ 顺时针旋转方阵
  + 先沿着左上-右下对角线翻转
  + 再左右镜像翻转

### 1.2 链表

分为单向链表、双向链表、循环链表。`JCF.LinkedList`内部存储结构为双向链表，可作为栈和队列使用。

+ 从尾到头打印单向链表
  + 递归返回时打印节点；
  + 栈+循环
+ 倒数第n个节点：
  + 快慢指针，快的到达末尾，慢的就是结果。
+ 人字形链表的分叉点
  + 两个指针，第一次相同时为结果
+ 翻转链表
  + 递归到尾部，返回时切换指针方向。
+ 合并两个排序的链表
+ 用链表实现大数的和，345+456=801，用链表表示：5-4-3+6-5-4=1-0-8
  + 低位在前就可以直接两个的低位求和，计算是否进位，不进位部分放入结果链表。

### 1.3 树

```
1. 递归可以top-down 或 bottom-up；
1. 利用栈数据结构可以利用循环实现 top-down；
1. JCF中LinkedList 和ArrayDeque 是deque的实现，取代了Stack；
1. 需要处理树的同一层（按行打印）时，需要借助栈和循环实现。
```

1. 二叉树

   前序遍历、中序遍历、后序遍历

   + 根据前序和中序重建二叉树
     + 前序区间第一个节点是root，root在中序中可分隔左右子树
   + 后序遍历、不使用递归（借助栈实现）
   + 树的子结构
   + 二叉树的镜像 
   + 二叉树每个节点是0-9的数字，计算每条路径组成数字之和。
     + 父节点的sum递归给子节点，子节点将sum*10+自己得到新的sum；
     + 如果没有子节点，则返回sum，有则将sum递归给子节点；
     + 最后返回左右子树返回值的和。

2. 二叉搜索树 BST

3. 平衡二叉树(AVL)

4. 红黑树

   `JCF.HashMap`自1.8开始链表长度>8并且capicity>64时变为红黑树。

5. B树

6. B+树

   `innoDB`索引。

   

### 1.4 栈

先入后出，用作需要逆序的辅助，`JCF`对应的数据结构有`ArrayDeque`、`LinkedList`、`Stack`

+ 两个栈模拟队列

### 1.5 队列

先入先出，`JCF`对应的数据结构有`ArrayDeque`、`LinkedList`

### 1.6 Hash



## 2. 算法

### 2.1 排序

1. **Quick Sort**

   快排复杂度o（nlogn）是为什么。n是什么logn是什么

   + partition过程
     + 取第一个为base，第一个坑；
     + 然后从右往左找第一个大于base的数，填入左边的坑（拆东墙补西墙），
     + 从左往右找第一个小于等于base的数，填入右边的坑（拆西墙补东墙）；
     + 循环上两步，知道左右指针相遇，
     + 将base填入相遇指针。
   + **每次partition，就能确定一个数的最终位置**，可用于快速查找一个数组中的topk个数。

2. 冒泡排序

3. 插入排序

4. 堆排序

5. 希尔排序

### 2.2 查找

1. 二分查找
   + 旋转数组中最小的数字
     + 查找最小，目标在右区间，因此从左边推进l=mid+1，r=mid；
     + l推进时可能掉低点，因此下一轮mid和l比较时导致漏掉答案，因此l推进时最好和r进行比较。

### 2.3 解空间搜索

1. n个相同的礼物分给k个小朋友，给出所有划分方案
   + n个礼物和k-1个分隔符之间的排列
   + 利用递归，决定当前层应该放礼物还是分隔符

### 2.4 动态规划

​	动态规划题型重点是分析递归方程，**递归方程**刻画从上到下的规律，实现时，从下往上实现，往往需要辅助空间用以减少重复计算。

​	对于简单问题，如果递归方程出来之后可以考虑能否直接数学计算。

1. 计算两段文本的编辑距离

   ```
    D[i][j] = if charI=charJ: D[i-1][j-1] 
    		 = else: min{D[i-1][j],D[i][j-1],D[i-1][j-1]}+1
    		 分别表示，增加、删除、替换三种操作
   ```

2. 青蛙跳台阶，每次能跳1或2步，一共多少种跳法。

   ```
   T(n) = T(n-1)+T(n-2) // 表示最后一次跳的1步还是两步
   ```

   + 矩形覆盖
   + 斐波那契数列

3. 变态青蛙跳台阶,每次能跳1...n步

   + 思路一：递归方程

   ```
   T(n) = T(n-1)+T(n-2)+ ....T(n-n+1)
   T(n-1) = T(n-2)+ ....T(n-n+1)
   T(n) = 2T(n-1)
   ```

   + 思路二：每个台阶存在与否，表示那个台阶是否经过。共`pow(2,n-1)`

### 2.5 二进制

 	1. 输入一个整数，输出该数二进制表示中1的个数。
     + 1不断左移与输入数字&，结果正负证明该bit为0还是1.
 	2. 求base(double)的exponent(int)次方
     + pow(2,11)=pow(2, 1011)=pow(2, 0001)+pow(2, 0010)+pow(2, 1000)
     + exp不断右移，每次&1，结果为正数表示该bit有效
     + **正数右移计算更少**(负数右移填充不确定)：右移exp比左移1更好。

### 其他

1. 手写LRU
   + 继承LinkedHashMap实现，指定capicity，cacheSize，并继承`removeEldestEntry`使其不扩容大于cacheSize时进行丢弃。