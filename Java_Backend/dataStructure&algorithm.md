## 1. 数据结构

### 1.1 数组

+ [二维数组(从左到右递增，从上到下递增)中的查找](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
  + 从左下角开始，大于目标值往右，小于目标值往上

### 1.2 链表

分为单向链表、双向链表、循环链表。`JCF.LinkedList`内部存储结构为双向链表，可作为栈和队列使用。

+ 从尾到头打印单向链表
  + 递归返回时打印节点；
  + 栈+循环
+ 倒数第n个节点：
  + 快慢指针，快的到达末尾，慢的就是结果。
+ 人字形链表的分叉点
  + 两个指针，第一次相同时为结果
+ 翻转链表
  + 递归到尾部，返回时切换指针方向。
+ 合并两个排序的链表

### 1.3 树

1. 二叉树

   前序遍历、中序遍历、后序遍历

   + 根据前序和中序重建二叉树
   + 后序遍历、不使用递归（借助栈实现）
   + 树的子结构
   + 二叉树的镜像 

2. 二叉搜索树 BST

3. 平衡二叉树(AVL)

4. 红黑树

   `JCF.HashMap`自1.8开始链表长度>8并且capicity>64时变为红黑树。

5. B树

6. B+树

   `innoDB`索引。

   

### 1.4 栈

先入后出，用作需要逆序的辅助，`JCF`对应的数据结构有`ArrayDeque`、`LinkedList`、`Stack`

+ 两个栈模拟队列

### 1.5 队列

先入先出，`JCF`对应的数据结构有`ArrayDeque`、`LinkedList`

### 1.6 Hash



## 2. 算法

### 2.1 排序

1. **Quick Sort**

   快排复杂度o（nlogn）是为什么。n是什么logn是什么

2. 冒泡排序

3. 插入排序

4. 堆排序

5. 希尔排序

### 2.2 查找

1. 二分查找
   + 旋转数组中最小的数字
     + 查找最小，目标在右区间，因此从左边推进l=mid+1，r=mid；
     + l推进时可能掉低点，因此下一轮mid和l比较时导致漏掉答案，因此l推进时最好和r进行比较。

### 其他

1. 青蛙跳台阶，变态青蛙跳台阶
2. 最长公共子串
3. 一个二维数组从左到右递增，从上到下递增，判断某个数在不在里面
4. 浮点数的平方根
5. 手写LRU